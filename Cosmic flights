Description:
Въпреки успеха на последната совалка на SpaceX, наречена Дракон, инженерите на компанията
забравили най-ключовия момент в цялото мероприятие. Това било именно да изхвърлят един
кибер камион от най-новия модел в космоса (за успех в продажбите както повеляват традициите
на компанията). По тази причина задачата е възложена на вас лично от Мъск. За изпълнението и са
ви предоставени най-новата совалка на SpaceX, наречена 5G и естествено теглич за камиона.
Преди да започнете със тази задача обаче, трябва да намерите колко са възможните маршрути,
които може да поеме совалката, за да знаете какъв алгоритъм да приложите за намирането на
оптималния от тях.
Совалката излита от спейс център в САЩ с координати (0, 0, 1) и трябва да кацне на координати
(xm , ym, 0) . При излитане совалката достига точка (1, 0, 1) и за да кацне, трябва да се намира в
точка (xm - 1, ym, 1). Когато е във въздуха, совалката има възможност да прелети от точка (x, y, z)
- на същата височина в една от точките: (x+1, y, z), (x+1, y+1, z), (x+1, y-1, z);
- да се издигне до точка (x+1, y, z+1), (x+1, y+1, z+1) или (x+1, y-1, z+1) в случай, че z < h
(височината на международната космическа станция, която не е нужно да се преминава);
- да се спусне до точка (x+1, y, z-1), (x+1, y+1, z-1) или (x+1, y-1, z-1) в случай, че z>1 (за да не се
разбие в земята).
Няма ограничения за летене по x и y. Да се намери броя на маршрутите, по които совалката може
да осъществи мисията си. Тъй като тази бройка, може да бъде много голяма от вас се иска да
намерите остатъка и по модул 1000000007
Input Format
На първия ред на стандартния вход се въвеждат 3 числа - xm , ym и h.
Constraints
0 ≤ ym ≤ xm ≤ 20
0 < h ≤ 20
Output Format
Намерения брой маршрути разделен по модул на 1000000007.
Sample Input 0
4 0 1
Sample Output 0
3
Sample Input 1
4 1 5
Sample Output 1
4

Solution:

#include <iostream>
#include <queue>

long long mod = 1000000007;
long long dp[21][42][21];
int x, y, h;
int offset = 20;

bool is_valid(int x1, int y1, int z1)
{
    return z1 <= h && z1 >= 1 && x1 > 1;
}

long long solve(int x, int y, int z)
{
    if (x == 1 && y == 0 && z == 1)
    {
        return dp[x][y + offset][z];
    }

    if (!is_valid(x, y, z))
    {
        return 0;
    }

    if (dp[x][y + offset][z] != -1)
    {
        return dp[x][y + offset][z];
    }

    dp[x][y + offset][z] = solve(x - 1, y, z);
    dp[x][y + offset][z] += solve(x - 1, y - 1, z);
    dp[x][y + offset][z] += solve(x - 1, y + 1, z);

    dp[x][y + offset][z] += solve(x - 1, y, z - 1);
    dp[x][y + offset][z] += solve(x - 1, y - 1, z - 1);
    dp[x][y + offset][z] += solve(x - 1, y + 1, z - 1);

    dp[x][y + offset][z] += solve(x - 1, y, z + 1);
    dp[x][y + offset][z] += solve(x - 1, y - 1, z + 1);
    dp[x][y + offset][z] += solve(x - 1, y + 1, z + 1);

    dp[x][y + offset][z] %= mod;
    return dp[x][y + offset][z];
}

int main()
{
    scanf("%d %d %d", &x, &y, &h);

    for (int i = 0; i < 21; ++i)
    {
        for (int j = 0; j < 42; ++j)
        {
            for (int k = 0; k < 21; ++k)
            {
                dp[i][j][k] = -1;
            }
        }
    }

    dp[1][0+offset][1] = 1;
    solve(x - 1, y, 1);

    printf("%lld", dp[x - 1][y + offset][1]);
    return 0;
}
