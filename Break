Description:

Мими реши да си вземе малко почивка от ФМИ и да отиде на планина. Тя откри
чудесна забележителност - високи и стръмни скали, които са свързани с еднопосочни
въжени мостове. След известно разучаване и стана ясно, че съществува световен рекорд
за най-бързо стигане до последната скала и сега момичето е твърдо решено да го
подобри, или поне да постигне същото време. Това обаче се оказва доста сложна задача,
тъй като въжените мостове са нестабилни когато има силен вятър, те изискват определен
клас екипировка. За всеки мост Мими има информация за началната и крайната му точка,
времето което отнема да се премине по него, както и минималният клас екипировка, с
която може да се използва моста. Знаейки какъв е световния рекорд (най-малкото време
за което някой е успял да стигне от началната скала до последната), момичето иска да
открие най-ниския клас екипировка който ще и е необходим.
Скалите са номерирани от 1 до n. Мостовете са еднопосочни. Началната скала е с
номер 1, а крайната с номер n. Достатъчно е да се постигне същото време като рекорда,
не е задължително да е по-малко. Класовете екипировка са цели положителни числа. Ако
Мими разполага с определен клас екипировка, то тя може да използва всички мостове,
които изискват клас екипировка по-малък или равен на този, с който тя разполага.
Например, ако тя има екипировка клас 3, тя може да използва мостове изискващи
екипировка клас 1,2 или 3.
Вход:
От първия ред се въвеждат 3 числа - n,m,k - броят скали, броят мостове и
световния рекорд. От следващите m реда се въвеждат по 4 числа u,v,c,t - начална и
крайна точка на моста, минималния клас екипировка, необходим за преминаване през
него и времето необходимо за преминаване по моста.
Изход:
Изведете минималния клас екипировка, който Мими трябва да има, за да подобри
световния рекорд, или поне да го постигне. Ако това е невъзможно, изведете -1.
Ограничения:
1 ≤ n ≤ 100 000
1 ≤ m ≤ 300 000
1 ≤ u ≠ v ≤ n
1 ≤ c, t, k ≤ 1 000 000
Примерен вход: 
7 11 42
1 3 7 11
3 1 7 13
1 2 3 3

1 4 13 1
6 1 14 8
4 6 1 7
2 4 1 13
2 6 4 20
3 5 2 5
5 6 6 4
6 7 5 20
2 2 3
1 2 3 5
1 2 1 9
Примерен изход:

7
-1
Оптималният път е 1-3-5-6-7, който изисква екипировка клас 7 и времето за преминаване
40.

Solution:

#include <iostream>
#include <queue>

struct bridge
{
    int num;
    int equip;
    int dist;
    bridge() = default;
    bridge(int v, int c, int t)
        : num(v), equip(c), dist(t)
    {
    }

    const bool operator>(const bridge &other) const
    {
        return this->dist > other.dist;
    }

    const bool operator<(const bridge &other) const
    {
        return this->dist < other.dist;
    }
};

int n, m, k, u, v, c, t;
int dist[100005];
bool visited[100005];
std::vector<bridge> graph[100005];

bool dijkstra(int eq, int total, int n)
{
    std::fill(dist, dist + n + 1, INT32_MAX);
    std::fill(visited, visited + n + 1, false);
    std::priority_queue<bridge, std::vector<bridge>, std::greater<bridge>> nodes;
    dist[1] = 0;
    nodes.push(bridge(1, 0, 0));

    while (!nodes.empty())
    {
        bridge top = nodes.top();
        nodes.pop();

        if (visited[top.num])
        {
            continue;
        }

        visited[top.num] = true;

        for (auto it = graph[top.num].begin(); it != graph[top.num].end(); it++)
        {
            if (it->equip <= eq)
            {
                int new_dist = dist[top.num] + it->dist;

                if (dist[it->num] > new_dist)
                {
                    dist[it->num] = new_dist;
                    nodes.push(bridge(it->num, it->equip, new_dist));
                }
            }
        }
    }

    return dist[n] <= total;
}

int main()
{
    scanf("%d %d %d", &n, &m, &k);
    for (int i = 0; i < m; i++)
    {
        scanf("%d %d %d %d", &u, &v, &c, &t);
        graph[u].push_back(bridge(v, c, t));
    }

    int high = 2 * 1000000, low = 0, mid, answer = -1;

    while (high >= low)
    {
        mid = (high + low) / 2;
        if (dijkstra(mid, k, n))
        {
            answer = mid;
            high = mid - 1;
        }
        else
        {
            low = mid + 1;
        }
    }

    printf("%d", answer);

    return 0;
}
